# Работа с модулями в отдельных файлах в Rust

В Rust вы можете организовывать код в модули и размещать их в отдельных файлах. Это особенно полезно для больших проектов, где код необходимо структурировать и разделять по функциональности. В этом разделе мы рассмотрим, как взаимодействовать с модулями, которые находятся в других файлах с расширением `.rs`.

## Организация модулей по файлам

### Основные концепции

- **Модуль** в Rust соответствует пространству имён и может содержать функции, структуры, перечисления и другие элементы.
- **Файловая система** отражает структуру модулей. Имя файла или директории соответствует имени модуля.
- **Главный файл**: это `main.rs` для исполняемых проектов или `lib.rs` для библиотек.

### Варианты организации модулей

1. Модуль в отдельном файле.
2. Подмодуль в отдельной папке с именем модуля, содержащая файл `mod.rs` или отдельные файлы для каждого подмодуля.

## Пример 1: Модуль в отдельном файле

### Шаг 1: Создадим проект

Используйте Cargo для создания нового проекта:

```bash
cargo new my_project
cd my_project
```

### Шаг 2: Создадим модуль в отдельном файле

Создайте файл `math.rs` в корневой директории `src/`:

```plaintext
my_project/
├── Cargo.toml
└── src
    ├── main.rs
    └── math.rs
```

### Файл `src/math.rs`

```rust
// Определение модуля math

// Публичная функция сложения
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

// Публичная функция вычитания
pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

// Частная функция (не будет доступна за пределами модуля)
fn helper_function() {
    println!("Это вспомогательная функция");
}
```

### Шаг 3: Подключите модуль в `main.rs`

В файле `src/main.rs` необходимо объявить модуль и использовать его.

```rust
// main.rs

// Объявляем, что у нас есть модуль math в файле math.rs
mod math;

fn main() {
    let sum = math::add(5, 3);
    let difference = math::subtract(10, 7);

    println!("Сумма: {}", sum);
    println!("Разность: {}", difference);

    // math::helper_function(); // Ошибка: функция не публичная
}
```

### Объяснение

- `mod math;` сообщает компилятору, что модуль `math` находится в файле `math.rs`.
- Функции `add` и `subtract` объявлены как `pub`, поэтому они доступны из `main.rs`.
- Функция `helper_function` не публичная, поэтому она недоступна за пределами `math.rs`.

### Шаг 4: Запустите программу

```bash
cargo run
```

Вывод:

```
Сумма: 8
Разность: 3
```

---

## Пример 2: Модули в подпапках

Когда ваш проект растёт, вы можете захотеть организовать модули в подпапках.

### Шаг 1: Создайте структуру директорий

```plaintext
my_project/
├── Cargo.toml
└── src
    ├── main.rs
    └── network
        ├── mod.rs
        ├── client.rs
        └── server.rs
```

### Файл `src/network/mod.rs`

```rust
// Объявляем подмодули
pub mod client;
pub mod server;
```

### Файл `src/network/client.rs`

```rust
pub fn connect() {
    println!("Клиент подключается");
}
```

### Файл `src/network/server.rs`

```rust
pub fn start() {
    println!("Сервер запускается");
}
```

### Файл `src/main.rs`

```rust
// Объявляем модуль network
mod network;

fn main() {
    network::client::connect();
    network::server::start();
}
```

### Объяснение

- В `main.rs` мы объявляем модуль `network`, который находится в папке `network`.
- В `network/mod.rs` мы объявляем подмодули `client` и `server`.
- Файлы `client.rs` и `server.rs` содержат соответствующие модули.

### Шаг 2: Запустите программу

```bash
cargo run
```

Вывод:

```
Клиент подключается
Сервер запускается
```

---

## Правила и соглашения

### Имена файлов и модулей

- Имя файла должно соответствовать имени модуля.
  - Модуль `math` — файл `math.rs`.
  - Подмодуль `network::client` — файл `network/client.rs`.
- Если модуль имеет подмодули, создаётся папка с именем модуля и в ней файл `mod.rs` (или напрямую файлы подмодулей).

### Объявление модулей

- В главном файле (`main.rs` или `lib.rs`) объявляем модули с помощью `mod`.
- В файле модуля (`mod.rs` или `*.rs`) объявляем подмодули с помощью `pub mod`.

### Видимость

- Элементы по умолчанию **частные**.
- Используйте `pub` для публичных элементов.
- Модули и подмодули также могут быть публичными или частными.

---

## Использование элементов из модулей

### Импорт с помощью `use`

Чтобы сократить пути к элементам, вы можете использовать `use`.

#### Пример

```rust
// main.rs

mod network;

use network::client;

fn main() {
    client::connect();
}
```

Или импортировать сразу функцию:

```rust
use network::client::connect;

fn main() {
    connect();
}
```

### Псевдонимы при импорте

Вы можете задавать псевдонимы для импортированных элементов.

```rust
use network::client::connect as client_connect;

fn main() {
    client_connect();
}
```

---

## Практические советы

- Разделяйте код по функциональности, используя модули и подмодули.
- Модули не должны зависеть друг от друга рекурсивно.
- Делайте элементы публичными только тогда, когда это необходимо.
- Используйте `use` для удобства, это делает код более читаемым и управляемым.
- Следуйте соглашениям по именованию, это облегчает понимание структуры проекта другими разработчиками.

---

## Особенности Edition 2018 и выше

В Rust 2018 и более новых редакциях были внесены изменения в систему модулей:

- **Нет необходимости использовать `mod.rs`**, если вы можете называть файл модуля так же, как и модуль.
  - Вместо `network/mod.rs` можно использовать `network.rs`.
  - Если у вас есть папка `network`, вы можете иметь файл `network.rs` и папку `network/`.

### Пример без `mod.rs`

```plaintext
my_project/
├── Cargo.toml
└── src
    ├── main.rs
    ├── network.rs
    └── network
        ├── client.rs
        └── server.rs
```

#### Файл `src/network.rs`

```rust
pub mod client;
pub mod server;
```

---

## Работа с несколькими уровнями модулей

### Пример глубокой иерархии

```plaintext
my_project/
└── src
    ├── main.rs
    └── utilities
        ├── mod.rs
        └── string_utils
            ├── mod.rs
            └── formatting.rs
```

#### Создай `src/utilities/mod.rs`

```rust
pub mod string_utils;
```

#### Создай `src/utilities/string_utils/mod.rs`

```rust
pub mod formatting;
```

#### Создай `src/utilities/string_utils/formatting.rs`

```rust
pub fn capitalize(s: &str) -> String {
    s.chars().next().unwrap().to_uppercase().collect::<String>() + &s[1..]
}
```

#### Создай `src/main.rs`

```rust
mod utilities;

fn main() {
    let text = "rustacean";
    let capitalized = utilities::string_utils::formatting::capitalize(text);
    println!("Капитализация: {}", capitalized);
}
```

---

## Использование `super` и `self` в модулях

Внутри модулей вы можете ссылаться на родительские и текущие модули с помощью `super` и `self`.

### Пример использования `super`

```rust
// src/parent.rs
pub mod child {
    pub fn child_function() {
        super::parent_function();
    }
}

pub fn parent_function() {
    println!("Это функция родительского модуля");
}
```

---

## Короткий алгоритм работы

Для взаимодействия с модулями, находящимися в других файлах `.rs`, необходимо:

- **Объявить модуль** в главном файле с помощью `mod module_name;`.
- **Создать файл** с именем модуля `module_name.rs` или папку `module_name/` с файлом `mod.rs`.
- **Указывать модификаторы доступа** (`pub`), чтобы элементы модуля были доступны извне.
- **Использовать путь к элементам** (`module::element`) или импортировать их с помощью `use`.
