# Модули в Rust: Что это такое и как с ними работать

## Что такое модуль?

**Модуль** (классы) в Rust — это способ организации кода в отдельные **пространства имён**. Модули позволяют группировать связанные функции, структуры, перечисления, константы и другие элементы. Они помогают структурировать код, избегать конфликтов имён и управлять видимостью элементов.

Модули позволяют:

- **Организовывать код** в логические части.
- **Управлять видимостью** (публичные и частные элементы).
- **Реализовывать инкапсуляцию**, скрывая детали реализации.

## Объявление и использование модулей

### Объявление модуля

Модули объявляются с помощью ключевого слова `mod`. Есть два способа объявления модулей:

1. **Внутренний модуль** (inline module) - модуль определяется внутри текущего файла.
2. **Внешний модуль** (file module) - модуль определяется в отдельном файле.

#### Пример: Внутренний модуль

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
}
```

В этом примере мы объявили модуль `math`, содержащий публичную функцию `add`.

### Использование модулей

Чтобы использовать элементы из модуля, необходимо ссылаться на них с помощью пути (path) или использовать ключевое слово `use`.

#### Пример использования модуля

```rust
fn main() {
    let result = math::add(2, 3);
    println!("Результат: {}", result);
}
```

### Импорт элементов из модуля

Вы можете импортировать элементы из модуля с помощью `use`.

```rust
use math::add;

fn main() {
    let result = add(2, 3);
    println!("Результат: {}", result);
}
```

## Внешние модули и файловая структура

### Разделение модулей по файлам

Если модуль становится большим, его можно вынести в отдельный файл.

#### Пример

Файл `main.rs`:

```rust
mod math; // Заявляем, что существует модуль math в файле math.rs

fn main() {
    let result = math::add(2, 3);
    println!("Результат: {}", result);
}
```

Файл `math.rs`:

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### Подмодули

Модули могут содержать подмодули.

#### Пример

Файл `main.rs`:

```rust
mod utils {
    pub mod math {
        pub fn add(a: i32, b: i32) -> i32 {
            a + b
        }
    }
}

fn main() {
    let result = utils::math::add(2, 3);
    println!("Результат: {}", result);
}
```

## Видимость и модификаторы доступа

По умолчанию, все элементы в модуле являются **частными** (private). Чтобы сделать элемент доступным за пределами модуля, необходимо использовать ключевое слово `pub`.

### Пример

```rust
mod math {
    fn private_function() {
        println!("Это частная функция");
    }

    pub fn public_function() {
        println!("Это публичная функция");
    }
}

fn main() {
    // math::private_function(); // Ошибка: функция private_function не доступна
    math::public_function(); // Доступно
}
```

## Передача данных в модуль и получение результатов

Модули в Rust не являются объектами или структурами, они не имеют конструкторов и не могут принимать параметры при создании. Вместо этого вы передаёте данные в функции, определённые внутри модулей.

### Функции внутри модулей

Вы можете определять функции внутри модулей, которые принимают параметры и возвращают значения.

#### Пример

```rust
mod math {
    pub fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
}

fn main() {
    let result = math::multiply(4, 5);
    println!("Результат умножения: {}", result);
}
```

## Структуры внутри модулей

Вы можете определять структуры внутри модулей, а затем создавать экземпляры этих структур и работать с ними.

### Пример использования структур

```rust
mod shapes {
    pub struct Rectangle {
        width: u32,
        height: u32,
    }

    impl Rectangle {
        // Публичный конструктор
        pub fn new(width: u32, height: u32) -> Self {
            Self { width, height }
        }

        // Публичный метод
        pub fn area(&self) -> u32 {
            self.width * self.height
        }
    }
}

fn main() {
    let rect = shapes::Rectangle::new(10, 5);
    println!("Площадь прямоугольника: {}", rect.area());
}
```

В этом примере:

- Мы определили модуль `shapes`, содержащий структуру `Rectangle`.
- У структуры есть публичный метод `new`, который действует как конструктор.
- Поля структуры являются частными, поэтому доступны только внутри модуля.
- Метод `area` позволяет получить площадь прямоугольника.

## Как передавать данные между модулями

Данные передаются между модулями с помощью функций, методов и структур.

### Передача данных в функции

Функции внутри модулей могут принимать параметры.

```rust
mod utils {
    pub fn greet(name: &str) {
        println!("Привет, {}!", name);
    }
}

fn main() {
    utils::greet("Алиса");
}
```

### Возврат значений из функций

Функции могут возвращать значения.

```rust
mod math {
    pub fn square(number: i32) -> i32 {
        number * number
    }
}

fn main() {
    let num = 6;
    let sq = math::square(num);
    println!("Квадрат {} равен {}", num, sq);
}
```

## Конструкторы в контексте структур

Хотя модули не имеют конструкторов, вы можете определить конструкторы для структур с помощью ассоциированных функций.

### Пример конструктора для структуры

```rust
mod person {
    pub struct Person {
        name: String,
        age: u8,
    }

    impl Person {
        // Публичный конструктор
        pub fn new(name: &str, age: u8) -> Self {
            Self {
                name: name.to_string(),
                age,
            }
        }

        // Публичный метод
        pub fn greet(&self) {
            println!("Меня зовут {}, мне {} лет", self.name, self.age);
        }
    }
}

fn main() {
    let alice = person::Person::new("Алиса", 30);
    alice.greet();
}
```

## Совместная работа нескольких модулей

Вы можете использовать элементы из одного модуля в другом модуле, учитывая модификаторы доступа.

### Пример

```rust
mod network {
    pub mod server {
        pub fn start_server() {
            println!("Сервер запущен");
        }
    }

    pub mod client {
        pub fn connect() {
            println!("Клиент подключается");
        }
    }
}

fn main() {
    network::server::start_server();
    network::client::connect();
}
```

## Советы по работе с модулями

- **Организуйте код логически** и разбивайте код на модули по функциональности (SOLID).
- **Управляйте видимостью**, т.е. используйте `pub` для элементов, которые должны быть доступны извне.
- **Избегайте слишком больших модулей** и разбивайте их на подмодули при необходимости.
- **Используйте `use` для сокращения путей**, это делает код более читаемым.

### Использование `use` для сокращения путей

```rust
use network::server;

fn main() {
    server::start_server();
}
```