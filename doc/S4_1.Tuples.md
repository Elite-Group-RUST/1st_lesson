# Что такое `impl` и зачем он нужен?

В Rust структуры (struct) и перечисления (enum) — это просто данные, и сами по себе они не содержат поведение. Чтобы добавить поведение (методы) к этим данным, используется ключевое слово `impl`. Оно создаёт блок реализации методов для структуры или перечисления.

**Пример:** 
Допустим, у нас есть структура `Rectangle`, которая хранит длину и ширину прямоугольника.

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
```

Для того чтобы добавить метод, который вычисляет площадь прямоугольника, создадим блок `impl`:

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
```

Теперь у структуры `Rectangle` появился метод `area`, который возвращает площадь. Этот метод можно вызывать на экземплярах структуры:

```rust
fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    
    println!("Площадь прямоугольника: {} квадратных пикселей", rect.area());
}
```

#### Разбор `&self`

- `self` — это текущий экземпляр структуры, с которым работает метод.
- `&self` — это **ссылка** на объект, позволяющая методу **чтение** данных объекта, не изменяя их.

Когда ты пишешь метод, использующий `&self`, это значит, что метод будет иметь доступ к экземпляру структуры, но не будет его изменять.

### Пример с изменением объекта: `&mut self`

Если метод должен изменять данные объекта, необходимо использовать изменяемую ссылку `&mut self`. Давай добавим метод, который изменяет размер прямоугольника:

```rust
impl Rectangle {
    fn resize(&mut self, new_width: u32, new_height: u32) {
        self.width = new_width;
        self.height = new_height;
    }
}
```

Этот метод принимает `&mut self`, что означает, что он может изменять поля объекта. Пример использования:

```rust
fn main() {
    let mut rect = Rectangle { width: 30, height: 50 };
    
    rect.resize(60, 100);  // Изменяем размер прямоугольника
    
    println!("Новый размер прямоугольника: {} на {}", rect.width, rect.height);
}
```

Здесь метод `resize` изменяет поля `width` и `height` у объекта `rect`.

### Когда используется просто `self`?

Если метод должен **забрать владение** объектом, используется просто `self` (без ссылки). В этом случае метод как бы "забирает" экземпляр структуры, и он больше не может быть использован после этого.

**Пример:**
Представим, что у нас есть структура `Container`, которая содержит значение, и метод, который возвращает это значение, забирая владение объектом:

```rust
struct Container {
    value: String,
}

impl Container {
    fn take_value(self) -> String {
        self.value
    }
}
```

Теперь объект `Container` передаётся в метод по значению, а не по ссылке. После вызова метода, объект больше нельзя использовать:

```rust
fn main() {
    let container = Container { value: String::from("Привет!") };
    
    let value = container.take_value();
    
    // Нельзя больше использовать container, т.к. его владение передано методу.
    // println!("{:?}", container); // Это вызовет ошибку компиляции
    
    println!("Значение: {}", value);
}
```

### Итог

1. **`impl`** используется для добавления методов к структурам или типам данных.
2. **`&self`** — это неизменяемая ссылка на объект, используется, когда метод не изменяет объект.
3. **`&mut self`** — это изменяемая ссылка на объект, используется, когда метод изменяет объект.
4. **`self`** используется, когда метод должен забрать владение объектом, после чего он больше не может быть использован.

### Дополнительный пример: методы с различными типами `self`

Давай объединим всё в одном примере для лучшего понимания:

```rust
struct Counter {
    count: u32,
}

impl Counter {
    // Метод возвращает значение, не изменяя объект
    fn get_count(&self) -> u32 {
        self.count
    }

    // Метод изменяет значение, поэтому используется &mut self
    fn increment(&mut self) {
        self.count += 1;
    }

    // Метод забирает владение объектом
    fn reset(self) -> Counter {
        Counter { count: 0 }
    }
}

fn main() {
    let mut counter = Counter { count: 5 };
    
    println!("Текущий счётчик: {}", counter.get_count());
    
    counter.increment();
    println!("После инкремента: {}", counter.get_count());
    
    // После вызова метода reset, объект counter перестанет быть доступен
    counter = counter.reset();
    println!("После сброса: {}", counter.get_count());
}
```

В этом примере:
- `get_count` использует `&self` для доступа к объекту, не изменяя его.
- `increment` использует `&mut self`, чтобы изменить значение `count`.
- `reset` использует `self`, чтобы забрать объект и вернуть новый с обнулённым значением.

