# Работа с структурой проекта 

**В Rust код не обязательно хранить в одном файле.** Наоборот, разделение кода на модули и файлы является хорошей практикой, особенно для больших проектов. Рассмотрим, как можно разделить `struct` и реализацию (`impl`) на разные файлы и папки.

### Структура проекта

Для примера разделим проект на две части:
- В одной директории будет храниться структура (`struct`).
- В другой — её реализация (`impl`).

Создадим следующую структуру файлов:

```
my_project/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── shapes/
    │   ├── mod.rs
    │   └── rectangle.rs
    └── utils/
        ├── mod.rs
        └── rectangle_impl.rs
```

### Шаг 1: Создаём структуру в отдельном файле

Создадим файл `shapes/rectangle.rs`, в котором будет определена наша структура `Rectangle`:

```rust
// src/shapes/rectangle.rs
pub struct Rectangle {
    pub width: u32,
    pub height: u32,
}
```

Здесь структура `Rectangle` является публичной (`pub`), чтобы к ней можно было обращаться из других модулей.

### Шаг 2: Создаём модуль для структуры

Теперь нужно создать файл `shapes/mod.rs`, чтобы подключить наш файл `rectangle.rs`:

```rust
// src/shapes/mod.rs
pub mod rectangle;
```

### Шаг 3: Реализация методов в другом файле

Теперь создадим файл `utils/rectangle_impl.rs`, где будет находиться реализация методов для структуры `Rectangle`:

```rust
// src/utils/rectangle_impl.rs
use crate::shapes::rectangle::Rectangle;

impl Rectangle {
    pub fn area(&self) -> u32 {
        self.width * self.height
    }

    pub fn resize(&mut self, new_width: u32, new_height: u32) {
        self.width = new_width;
        self.height = new_height;
    }
}
```

Здесь мы используем `use crate::shapes::rectangle::Rectangle;`, чтобы импортировать структуру из модуля `shapes`. Далее, через `impl` мы добавляем методы `area` и `resize`.

### Шаг 4: Создаём модуль для реализации

Также нужно создать модульный файл `utils/mod.rs`, который подключит наш файл с реализацией:

```rust
// src/utils/mod.rs
pub mod rectangle_impl;
```

### Шаг 5: Главный файл `main.rs`

Теперь подключим модули в файле `main.rs` и используем структуру и её методы:

```rust
// src/main.rs
mod shapes;
mod utils;

use shapes::rectangle::Rectangle;

fn main() {
    let mut rect = Rectangle { width: 30, height: 50 };

    println!("Площадь прямоугольника: {}", rect.area());

    rect.resize(60, 100);
    println!("Новый размер прямоугольника: {} на {}", rect.width, rect.height);
}
```

Здесь мы:
- Объявляем модули `shapes` и `utils`.
- Используем структуру `Rectangle` из модуля `shapes`.
- Вызываем методы, которые определены в файле `rectangle_impl.rs`.

### Как это работает:

1. **Модули в Rust** позволяют разделять код на отдельные файлы и папки. В нашем случае структура `Rectangle` определена в одном файле (`rectangle.rs`), а её реализация — в другом (`rectangle_impl.rs`).
   
2. **Модульная система** в Rust поддерживает иерархическое разделение кода. Мы используем `mod` для подключения модулей и делаем структуры и функции публичными с помощью `pub`, чтобы их можно было использовать в других файлах.

3. **Импортирование структур и методов** происходит через `use`, и это позволяет организовать код в удобной и читаемой форме.

### Преимущества такого подхода:

- Код разделён на логические части, что упрощает его понимание и поддержку, влияя на его **читаемость**.
- **Масштабируемость** позволяет легко добавлять новые методы или структуры, не перегружая основной файл.
- **Переиспользование** и разделение кода позволяет легче переиспользовать компоненты в разных частях программы.