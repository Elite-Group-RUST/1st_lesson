# Вводное занятие по языку программирования Rust

**Rust** — это современный системный язык программирования, разработанный для обеспечения безопасности и высокой производительности. Он особенно популярен в областях, где критически важна безопасность памяти и параллелизм.

В этом занятии мы рассмотрим основные понятия Rust в папке `doc`:

- Переменные
- Типы данных
- Условия
- Циклы
- Массивы
- Кортежи

---

## Работа с переменными

В Rust переменные по умолчанию **неизменяемы** (immutable). Для объявления переменной используется ключевое слово `let`.

### Объявление неизменяемой переменной

```rust
let x = 5;
```

Здесь `x` — это переменная, которой присвоено значение `5`. Тип переменной выводится автоматически на основе присвоенного значения.

### Объявление изменяемой переменной

Чтобы сделать переменную изменяемой, используется ключевое слово `mut`:

```rust
let mut y = 10;
y = y + 5; // Теперь y равно 15
```

### Особенности переменных в Rust

- Неизменяемость по умолчанию, т.е. способствует написанию более безопасного кода.
- Явное указание изменяемости, что делает код более понятным и предотвращает непреднамеренные изменения данных.

---

## Типы данных

Rust является **СТАТИЧЕСКИ ТИПИЗИРОВАННЫМ** языком, то есть типы всех переменных должны быть известны во время компиляции.

### Примитивные типы данных

1. **Целые числа**:

   - Знаковые: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
   - Беззнаковые: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`

2. **Числа с плавающей точкой**:

   - `f32`, `f64`

3. **Булевы значения**:

   - `bool` (`true` или `false`)

4. **Символы**:

   - `char` (Unicode символы, занимающие 4 байта)

### Явное указание типа

```rust
let z: f64 = 3.14;
```

### Особенности типов данных

- Rust не выполняет неявные преобразования типов, создавая самые безопасные условия среди всех язков программирования.
- Важно учитывать **размеры типов данных** при работе с разными платформами и архитектурами.

---

## Условные операторы

Условия в Rust создаются с помощью `if`, `else if` и `else`.

### Пример использования условий

```rust
let number = 7;

if number < 5 {
    println!("Число меньше 5");
} else if number == 5 {
    println!("Число равно 5");
} else {
    println!("Число больше 5");
}
```

### Особенности условий

- **Условие должно быть булевым выражением**, т.е. нельзя использовать числа или другие типы.
- **`if` является выражением** и может возвращать значение.

```rust
let condition = true;
let number = if condition { 5 } else { 6 };
```

---

## Циклы

Rust предоставляет несколько видов циклов: `loop`, `while` и `for`.

### Цикл `loop`

Бесконечный цикл, который продолжается до явного выхода.

```rust
loop {
    println!("Это бесконечный цикл");
    break; // Выход из цикла
}
```

### Цикл `while`

Выполняется, пока условие истинно.

```rust
let mut count = 0;

while count < 5 {
    println!("Count is: {}", count);
    count += 1;
}
```

### Цикл `for`

Итерируется по коллекции или диапазону.

```rust
for number in 1..5 {
    println!("Number is: {}", number);
}
```

### Особенности циклов

- **Цикл `for` предпочтителен**: более безопасен и эффективен.
- **Диапазоны**: оператор `..` создаёт диапазон чисел.

---

## Массивы

Массивы в Rust — это коллекции элементов одного типа и фиксированной длины.

### Объявление массива

```rust
let a = [1, 2, 3, 4, 5];
```

Или с указанием типа и длины:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

### Доступ к элементам массива

```rust
let first = a[0];
let second = a[1];
```

### Итерирование по массиву

```rust
for element in a.iter() {
    println!("Элемент: {}", element);
}
```

### Особенности массивов

- **Фиксированный размер** - не может изменяться.
- **Индексирование** - начинается с нуля.
- **Безопасность доступа** при выходе за пределы массива программа аварийно завершится (panic).

---

## Кортежи

Кортежи — это коллекции фиксированной длины, которые могут содержать элементы разных типов.

### Объявление кортежа

```rust
let tup = (500, 6.4, 'a');
```

### Доступ к элементам кортежа

Через деструктуризацию:

```rust
let (x, y, z) = tup;
println!("x: {}, y: {}, z: {}", x, y, z);
```

Или по индексу:

```rust
let five_hundred = tup.0;
let six_point_four = tup.1;
let character = tup.2;
```

### Особенности кортежей

- **Разные типы** могут содержать элементы разных типов.
- Массивы и кортежи имеют фиксированный размер (длину).

---

## Как правильно работать с этими концепциями

### Неизменяемость и безопасность

- Используйте чаще неизменяемые переменные (по умолчанию) для повышения безопасности.
- Используйте `mut` только тогда, когда действительно нужно.

### Явное указание типов

- **Помогает улучшить читабельности**, особенно в сложных контекстах.
- **Упрощает отладку** и, как следствие, компилятор даст более понятные сообщения об ошибках.

### Использование условий и циклов

- **Условия** старайтесь делать их простыми и понятными.
- В **циклах** предпочтительней использовать `for` для итерирования по коллекциям.

### Работа с массивами и кортежами

- **Массивы** используйте только для хранения коллекций одного типа фиксированного размера.
- **Кортежи** удобно использовать для группировки разнородных данных, чаще всего используются из-за удобств работы и сортировки с ними.

### Особенности Rust

- Rust управляет памятью без сборщика мусора.
- Удобно работать с данными без их копирования (**принцип заимствование и ссылки**).
- Строгий **компилятор**, что помогает предотвращать множество ошибок на ранних стадиях.

---

# Практическая работа №1. Управление памятью и обработка ошибок в Rust
## Уровень Junior: Исправление ошибок в коде

#### Задание:
Вам предоставлен код программы на Rust, которая выполняет арифметические операции с числами и обрабатывает возможные ошибки. Однако в коде есть несколько ошибок, приводящих к некорректному выполнению программы. Ваша задача — найти и исправить их.

#### Исходный код:
```rust
fn divide_numbers(a: f64, b: f64) -> Result<f64, &'static str> {
    if b == 0.0 {
        return Err("Division by zero is not allowed");
    }
    Ok(a / b)
}

fn main() {
    let x = 10.0;
    let y = 0.0;

    let result = divide_numbers(x, y);
    
    match result {
        Ok(value) => println!("Result: {}", value),
        Err(e) => println!("An error occurred: {}", e),
    }

    let result_2 = divide_numbers(x, 5.0);
    if let Ok(value) = result_2 {
        println!("Second result: {}", value);
    }
}
```

#### Задание:
1. Найдите и исправьте логическую ошибку при делении на ноль, чтобы программа корректно обрабатывала эту ситуацию.
2. Улучшите сообщение об ошибке, добавив к нему более подробную информацию, например, какое именно выражение вызвало ошибку.
3. Добавьте проверку для отрицательных значений аргументов и верните ошибку в случае их использования, так как программа должна принимать только положительные числа.

#### Указания:
- Вам нужно внести минимальные правки в существующий код, чтобы программа правильно обрабатывала случаи с делением на ноль и отрицательными числами.
- Протестируйте программу с различными значениями переменных `x` и `y`.

---

## Уровень Senior: Разработка программы с использованием управления памятью и сложной обработки ошибок

#### Задание:
Разработайте программу на Rust, которая будет работать с коллекцией данных о товарах в магазине. Каждый товар должен иметь такие свойства, как название, цена и количество. Программа должна выполнять следующие операции:
1. Добавление товара.
2. Обновление цены или количества товара.
3. Поиск товара по названию.
4. Удаление товара.
5. Обработка ошибок при неправильном вводе данных или отсутствующем товаре в базе.

В программе необходимо:
- Использовать структуры для описания товара.
- Управлять памятью, эффективно используя владение и заимствование (ownership и borrowing).
- Обрабатывать ошибки, возвращая пользовательские ошибки с помощью `Result` и `Option`.

#### Требования к коду:
1. Реализовать структуру `Product`, которая будет хранить информацию о товаре (название, цена и количество).
2. Реализовать структуру `Store`, которая будет хранить коллекцию товаров.
3. Написать функции для добавления, обновления, поиска и удаления товаров.
4. Обрабатывать ошибки корректно: вернуть ошибку, если товар не найден или переданы некорректные данные.
5. Использовать владение и заимствование при работе с коллекцией товаров, избегая избыточного копирования данных.

#### Фрагменты кода для доработки:

**Структура товара и магазина:**
```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Product {
    name: String,
    price: f64,
    quantity: u32,
}

struct Store {
    products: HashMap<String, Product>,
}

impl Store {
    fn new() -> Store {
        Store {
            products: HashMap::new(),
        }
    }

    fn add_product(&mut self, name: String, price: f64, quantity: u32) -> Result<(), &'static str> {
        // Реализуйте добавление товара с проверкой корректности данных
    }

    fn update_product(&mut self, name: &str, new_price: Option<f64>, new_quantity: Option<u32>) -> Result<(), &'static str> {
        // Реализуйте обновление данных о товаре с проверкой наличия товара
    }

    fn find_product(&self, name: &str) -> Option<&Product> {
        // Реализуйте поиск товара по названию
    }

    fn remove_product(&mut self, name: &str) -> Result<(), &'static str> {
        // Реализуйте удаление товара с проверкой наличия товара
    }
}
```

#### Что нужно сделать:
1. **Реализовать функции:**
   - Добавление нового товара в магазин, с проверкой, что товар с таким названием ещё не существует. В случае неуспешного добавления вернуть ошибку.
   - Обновление цены и количества товара. Если указан только один параметр (цена или количество), измените только его.
   - Поиск товара по названию. Если товар не найден, вернуть `None`.
   - Удаление товара по названию с проверкой наличия товара. Вернуть ошибку, если товар не существует.
   
2. **Использование владения и заимствования:**
   - В функции добавления товара используйте `&mut self` для работы с коллекцией товаров.
   - В функции поиска товара используйте заимствование, возвращая ссылку на товар (`&Product`), чтобы избежать лишнего копирования данных.

3. **Обработка ошибок:**
   - Используйте `Result` и `Option` для работы с ошибками.
   - В случае некорректного ввода данных (например, отрицательная цена или количество) возвращайте соответствующую ошибку.

#### Пример использования:
```rust
fn main() {
    let mut store = Store::new();
    
    // Попытка добавить товар
    match store.add_product("Laptop".to_string(), 1000.0, 10) {
        Ok(_) => println!("Product added successfully"),
        Err(e) => println!("Error adding product: {}", e),
    }
    
    // Обновление товара
    match store.update_product("Laptop", Some(900.0), None) {
        Ok(_) => println!("Product updated successfully"),
        Err(e) => println!("Error updating product: {}", e),
    }
    
    // Поиск товара
    if let Some(product) = store.find_product("Laptop") {
        println!("Found product: {:?}", product);
    } else {
        println!("Product not found");
    }
    
    // Удаление товара
    match store.remove_product("Laptop") {
        Ok(_) => println!("Product removed successfully"),
        Err(e) => println!("Error removing product: {}", e),
    }
}
```

### Задание подразумевает:
- Внимательное управление памятью при работе с коллекцией (например, при возвращении ссылок на объекты).
- Обработку нескольких потенциальных ошибок (например, ошибки при добавлении существующего товара или обновлении несуществующего товара).
- Удобную структуру кода для дальнейшего расширения (например, добавление новых функций или методов).
